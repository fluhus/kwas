package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"runtime"

	"github.com/fluhus/gostuff/aio"
	"github.com/fluhus/gostuff/jio"
	"github.com/fluhus/gostuff/sets"
	"github.com/fluhus/kwas/gofisher"
	"github.com/fluhus/kwas/progress"
	"github.com/fluhus/kwas/util"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
)

var (
	sigf  = flag.String("s", "", "Input significant file")
	nsigf = flag.String("n", "", "Input nonsignificant file")
	outf  = flag.String("o", "", "Output file")
)

func main() {
	flag.Parse()
	fmt.Println("Loading significant counts:", *sigf)
	pt := progress.NewTimer()
	sigCounts, sigSum, err := loadGeneKmers(*sigf)
	pt.Done()
	util.Die(err)
	fmt.Println("Loading nonsignificant counts:", *nsigf)
	pt = progress.NewTimer()
	nsigCounts, nsigSum, err := loadGeneKmers(*nsigf)
	pt.Done()
	util.Die(err)
	runtime.GC()

	fmt.Println("Fishing")
	pt = progress.NewTimer()
	var tests []fisherResult
	for gene, count := range sigCounts {
		a := count
		b := sigSum - a
		c := nsigCounts[gene]
		d := nsigSum - c
		odr, p := gofisher.Greater(a, b, c, d)
		tests = append(tests, fisherResult{gene, odr, p})
	}
	pt.Done()

	tests = util.FilterSlice(tests, func(f fisherResult) bool {
		return f.pval <= 0.05/float64(len(tests))
	})
	fmt.Println(len(tests), "rnames are significant")
	slices.SortFunc(tests, func(a, b fisherResult) bool {
		return a.odr > b.odr
	})
	fmt.Println(tests[:3])

	sig := util.MapSlice(tests, func(f fisherResult) string {
		return f.rname
	})
	found := maps.Keys(sets.Set[string]{}.Add(maps.Keys(sigCounts)...).Add(
		maps.Keys(nsigCounts)...))
	slices.Sort(sig)
	slices.Sort(found)

	fmt.Println("Writing to:", *outf)
	util.Die(jio.Save(*outf,
		map[string][]string{"sig": sig, "found": found}))
}

// The result of a single Fisher test, for filtering and sorting.
type fisherResult struct {
	rname string
	odr   float64
	pval  float64
}

// Loads the counts generated by smfq.
func loadGeneKmers(file string) (map[string]int, int, error) {
	f, err := aio.Open(file)
	if err != nil {
		return nil, 0, err
	}
	defer f.Close()
	j := json.NewDecoder(f)
	counts := map[string]int{}
	kmers := sets.Set[int]{}
	for {
		m := struct {
			Gene  string
			Kmers []int
		}{}
		if err := j.Decode(&m); err != nil {
			if err == io.EOF {
				break
			}
			return nil, 0, err
		}
		counts[m.Gene] = len(m.Kmers)
		kmers.Add(m.Kmers...)
	}
	return counts, len(kmers), nil
}
